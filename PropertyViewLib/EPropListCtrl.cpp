/* Generated by Together */

#include "stdafx.h"
#include "EProperty.h"
#include "EPropList.h"
#include "IPropertyHost.h"
#include "EPropListCtrl.h"

#include "SetRawPixels.h"
#include "NodeOpen.h"
#include "NodeClosed.h"
#include "ECommentPane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(EPropListCtrl, EPropWnd)

BEGIN_MESSAGE_MAP(EPropListCtrl, EPropWnd)
	//{{AFX_MSG_MAP(EPropListCtrl)
	ON_WM_ERASEBKGND()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_PAINT()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int gAnimDropTable[] =
{
//	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
	0,
	1,
	3,
	6,
	10,
	15,
	21,
	28,
	36,
	45,
	55,
};


void EPropListCtrl::OnTimer( UINT nTimer )
{
	Invalidate();
}

//afx_msg void EPropListCtrl::QQQ()
//{
//	TRACE("RR");
//}

EPropListCtrl::EPropListCtrl()
{
	m_bAutoSizeKeyColumn = false;

	m_nKeyColumnWidth = 100;
	m_nSplitWidth     = 6;


	m_nMouseDownKeyColumnWidth  = -1;
	m_nMouseDownMousePositionSP = -1;

	m_pPropertyHost   = NULL;

	m_bHScrollEnabled = false;
	m_bVScrollEnabled = false;

	m_pDrawnProperties = NULL;
	m_nDrawnPropertiesSize = 0;

	m_bAnimating = false;
}

EPropListCtrl::~EPropListCtrl()
{
	if( m_pDrawnProperties != NULL )
	{
		delete m_pDrawnProperties;
		m_pDrawnProperties = NULL;
	}
}

//
// prepare drawn properties list, and properties rect's
//
// use for hittest, simplify drawing
//
void EPropListCtrl::_UpdateDrawnPropertiesList( CDC* pDC )
{
	//
	// fit propterty array size
	//

	if( m_PropList.Size() > m_nDrawnPropertiesSize )
	{
		if( m_pDrawnProperties != NULL )
		{
			delete m_pDrawnProperties;
		}
		m_nDrawnPropertiesSize = m_PropList.Size();
		m_pDrawnProperties = new EProperty*[ m_nDrawnPropertiesSize ];
	}

	//
	//
	//

	EProperty* pOldProperty = NULL;
	int nNumProperties = m_PropList.Size();

	//
	// set has_children flags
	//

	for( int i=0 ; i<nNumProperties ; i++ )
	{
		EProperty* pProp = m_PropList.Get(i);

		pProp->m_bHasChildren = false;		//default to false

		if( pOldProperty != NULL )
		{
			if( pProp->m_nIndent > pOldProperty->m_nIndent )
			{
				pOldProperty->m_bHasChildren = true;
			}
		}

		pOldProperty = pProp;
	}

	//
	// set rect y-values for all properties, build shownproperties list
	//

	m_nNumDrawnProperties = 0;

	int  nLastOpenIndent   = 0;
	bool bLastPropWasShown = true;
	bool bLastPropWasOpen  = true;

	int y0 = 0;

	for( i=0 ; i<nNumProperties ; i++ )
	{
		EProperty* pProp = m_PropList.Get(i);

		bool bShown = true;

		if( pProp->m_nIndent > nLastOpenIndent )
		{
			if( bLastPropWasShown && bLastPropWasOpen )
			{
			}
			else
			{
				bShown = false;
			}
		}

		if( bShown )
		{
			int nHeight = pProp->GetHeight(pDC) + m_nEdgeWidth * 2;		//height of this property panel inclusive borders

			pProp->m_Rect.SetRect( 0 , y0 , 0 , y0 + nHeight );

			m_pDrawnProperties[m_nNumDrawnProperties++] = pProp;

			y0 += nHeight;

			nLastOpenIndent = pProp->m_nIndent;
		}
		else
		{
			pProp->m_Rect.SetRect( 0 , y0 , 0 , y0 );
		}

		bLastPropWasShown = bShown;
		bLastPropWasOpen  = pProp->m_bNodeOpen;
	}

	m_ScrollPageSize.cy = y0;

	//
	// calculate scrollpage size
	//

	m_nOptimalValColumnWidth = 0;

	for( i=0 ; i<m_nNumDrawnProperties ; i++ )
	{
		EProperty* pProp = m_pDrawnProperties[i];
		int w = pProp->GetPreferedWidth(pDC);
		if( w>m_nOptimalValColumnWidth )
		{
			m_nOptimalValColumnWidth = w;
		}
	}

	m_ScrollPageSize.cx = m_nKeyColumnWidth + m_nSplitWidth + m_nOptimalValColumnWidth;

	//
	//
	//

	SetScrollPage();

}

void EPropListCtrl::OnPaint()
{
	CRect   cr;
	GetClientRect(&cr);

	CPaintDC dc(this);
	CDC* pDC = &dc;

	//
	//
	//

//----------------
// flicker
//----------------
	CDC* pParsedDC = pDC;
	CDC     MemDC;
	CBitmap MemBM;
	MemBM.CreateCompatibleBitmap(pParsedDC,cr.Width(),cr.Height());
	MemDC.CreateCompatibleDC(pParsedDC);
	MemDC.SelectObject(&MemBM);
	pDC = &MemDC;
//----------------
	
	//
	//
	//

//this causes a problem with the active property, which is erased when clearing
//	if( m_pPropertyHost != NULL )
//	{
//		m_PropList.Clear();
//		m_pPropertyHost->GetProperties( m_PropList );
//	}

	//
	//
	//

	m_vpo.y = -GetScrollPos(SB_VERT);
	m_vpo.x = -GetScrollPos(SB_HORZ);
	
	CPoint ScrollPageBottomRight = _CP2SP(cr.BottomRight());

	pDC->SelectObject( &m_Font );
	pDC->SetBkMode(TRANSPARENT);

	pDC->SetViewportOrg(m_vpo);

	int nKeyColumnBegin = 0;	//m_vpo.x;	//vpo.x;
	int nSplitBegin     = nKeyColumnBegin + m_nKeyColumnWidth;
	int nValColumnBegin = nSplitBegin + m_nSplitWidth;
	int nValColumnEnd   = ScrollPageBottomRight.x;

	CRect r;

	//
	//
	//

	CRect ViewRectSP = _CP2SP(cr);

	//
	//
	//
	
	int nAnimYDisplacement = 0;
	int nAnimNumFrames = sizeof(gAnimDropTable)/sizeof(int);
	CRect AnimClipRect;

	//
	//
	//

	if( m_PropList.Size() == 0 )
	{
		DrawFrame( pDC , cr , true , GetColorPaneKey() );
		pDC->SetTextAlign( TA_CENTER );
		
		CString s = (m_pChangeListener==NULL) ? "NO PROPERTIES" : m_pChangeListener->GetNoPropertiesMessage();

		pDC->TextOut( cr.Width()/2 , 10 , s );
	}
	else
	{
		pDC->SetTextAlign( TA_TOP );

		for( int i=0 ; i<m_nNumDrawnProperties ; i++ )
		{
			EProperty* pProp = m_pDrawnProperties[i];

			//
			// 0          1  2                3  4   5  6    7                      8
			// +----------+--+----------------+--+---+--|    |----------------------+
			// |          |  |                |  |   |  |    |                      |
			// |          |  |                |  +---+  |    |                      |
			// | <indent> |  TEXT             |  |   |  |    |                      |
			// |          |  |                |  +---+  |    |                      |
			// |          |  |                |  |   |  |    |                      |
			// +----------+--+----------------+--+---+--|    |----------------------+
			//

			int x0 = nKeyColumnBegin;
			int x1 = x0 + pProp->m_nIndent * 13;
			int x2 = x1 + (m_nEdgeWidth + 4);
			int x6 = nSplitBegin;
			int x5 = x6 - (m_nEdgeWidth + 4);
			int x4 = x5;
			int x3 = x5;
			if( pProp->m_bHasChildren )
			{
				x4 = x5 - pNodeClosed[0];
				x3 = x4 - 4;
			}

			//
			// prepare for y-displacement if animating
			//

			CRect oldr = pProp->m_Rect;
			if( m_bAnimating )
			{
				if( i>=m_nAnimFirstOpeningChild )	//at first opening child property, setup clip region
				{
					int nMaxValue  = gAnimDropTable[ nAnimNumFrames-1 ];

					int nCurValue  = gAnimDropTable[ nAnimNumFrames-m_nAnimCurrentFrame-1 ];

					if( true )
					{
			//			nCurValue  = nMaxValue - gAnimDropTable[ m_nAnimCurrentFrame ];
					}

					nAnimYDisplacement = - m_nAnimChildrensHeight * (nCurValue) / nMaxValue;

					if( i==m_nAnimFirstOpeningChild )
					{
						AnimClipRect.SetRect( 0 , oldr.top+m_vpo.y , cr.right , cr.bottom );
						CRgn rgn;
						rgn.CreateRectRgn( AnimClipRect.left , AnimClipRect.top , AnimClipRect.right , AnimClipRect.bottom );
						pDC->SelectClipRgn( &rgn);
					}

					pProp->m_Rect.OffsetRect( 0 , nAnimYDisplacement );
				}
			}

			//
			//
			//

			if( pProp->m_Rect.bottom < ViewRectSP.top )
			{
				pProp->m_Rect = oldr;
				continue;
			}

			if( pProp->m_Rect.top >= ViewRectSP.bottom )
			{
				pProp->m_Rect = oldr;
				break;
			}

			//
			//
			//

			r = pProp->m_Rect;

			//
			// draw indent area
			//

			r.left  = x0;
			r.right = x1;
			pDC->FillSolidRect( &r , GetColorPaneKey() );

			//
			// draw key frame
			//

			r.left  = x1;
			r.right = x6;

			DrawFrame( pDC , r , true , pProp->GetColorKey(this) );

			//
			// the key tekst
			//

			r.left  = x2;
			r.right = x3;

			CString s = pProp->GetName();								//key text

			s = EPropWnd::s_FitStringToWidth(s,r.Width(),pDC);
			pDC->DrawText( s , &r , DT_VCENTER | DT_SINGLELINE );

			//
			// node open button
			//

			if( pProp->m_bHasChildren )
			{
				CRect nr( 0 , 0 , pNodeClosed[0] , pNodeClosed[1] );

				if( true )	//right aligned
				{
					nr.OffsetRect( x4 , r.top+6 );
				}

				pProp->m_NodeOpenRect = nr;
				CPoint p = pProp->m_NodeOpenRect.TopLeft();
				CPoint vpo = pDC->OffsetViewportOrg(p.x,p.y);
				int* pPixels =  pProp->m_bNodeOpen ? pNodeOpen : pNodeClosed;
				SetRawPixels( pDC , pPixels );
				pDC->SetViewportOrg( vpo );
			}

			//
			// value panel
			//

			pProp->m_Rect.left  = nValColumnBegin;
			pProp->m_Rect.right = nValColumnEnd;

			DrawFrame( pDC , pProp->m_Rect , true , -1 );

			pProp->m_Rect.DeflateRect(m_nEdgeWidth,m_nEdgeWidth);
			pProp->Draw( pDC , this );
			pProp->m_Rect.InflateRect(m_nEdgeWidth,m_nEdgeWidth);

			pProp->m_Rect = oldr;
		}

		pDC->SelectClipRgn(NULL);		//if animating, cliprect may have been used

		//
		// splitter
		//

		r.left   = nSplitBegin;
		r.right  = nValColumnBegin;
		r.top    = 0;
		r.bottom = r.bottom;

		DrawFrame( pDC , r , true , GetColorPaneKey() );		//splitter

		m_SplitRectSP = r;

		//
		// empty bottom
		//

		int nViewBottom = cr.bottom - m_vpo.y;

		if( nViewBottom > m_ScrollPageSize.cy + nAnimYDisplacement )
		{
			r.left   = nKeyColumnBegin;
			r.right  = nValColumnEnd;
			r.top    = m_ScrollPageSize.cy + nAnimYDisplacement;
			r.bottom = nViewBottom;
//---------------------------
			DrawFrame( pDC , r , true , GetColorPaneKey() );
//---------------------------
//			pDC->FillSolidRect( r , GetColorPaneKey() );
//---------------------------
		}


	}


	if( m_bAnimating )
	{
		//
		// Outline animation clipping rect
		//

//------------
//		CPoint vpo = pDC->SetViewportOrg(0,0);
//		CPen red;
//		red.CreatePen(PS_SOLID , 2 , RGB(255,0,0) );
//		CPen* pPen = (CPen*)pDC->SelectObject(&red);
//		pDC->SelectStockObject(NULL_BRUSH);
//		AnimClipRect.InflateRect(-1,-1);
//		pDC->Rectangle(AnimClipRect);
//		AnimClipRect.InflateRect( 1, 1);
//------------

		m_nAnimCurrentFrame++;

		if( m_nAnimCurrentFrame==nAnimNumFrames )
		{
			KillTimer(0);
			m_bAnimating = false;
		}
	}

//--------------------------
// flicker
//--------------------------
	MemDC.SetViewportOrg(0,0);
	pParsedDC->BitBlt( 0 , 0 , cr.Width() , cr.Height() , &MemDC , 0 , 0 , SRCCOPY );
//--------------------------
}




/*
void EPropListCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	TRACE("view keydown\n");
	if( nChar == 27 )	//escape
	{
		if( m_pActiveProperty != NULL )
		{
			m_pActiveProperty->CancelEdit();
			m_pActiveProperty = NULL;
			Invalidate();
		}
	}
	else
	{
		CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}
*/

void EPropListCtrl::OnLButtonUp(UINT nFlags, CPoint cp) 
{
	m_nMouseDownMousePositionSP  = -1;
	m_nMouseDownKeyColumnWidth   = -1;
	ReleaseCapture();
	CWnd::OnLButtonUp(nFlags, cp);
}

//void EPropListCtrl::OnLButtonDblClk( UINT nFlags , CPoint point)
//{
//	TRACE("Double Click\n");
//	OnLButtonDown( nFlags , point );
//}

CPoint EPropListCtrl::_CP2SP( CPoint cp )
{
	return cp - m_vpo;
}

CRect EPropListCtrl::_CP2SP( CRect cp )
{
	CRect r = cp;
	r.OffsetRect( -m_vpo );
	return r;
}

void EPropListCtrl::OnLButtonDown(UINT nFlags, CPoint cp) 
{
	CPoint sp = _CP2SP(cp);

	SetFocus();

	if( m_PropList.Size() == 0 )
	{
		return;
	}

	if( m_SplitRectSP.PtInRect(sp) )			//begin split move?
	{
		m_nMouseDownKeyColumnWidth  = m_nKeyColumnWidth;
		m_nMouseDownMousePositionSP = sp.x;
		SetCapture();
		SetCursor( LoadCursor(NULL,IDC_SIZEWE) );
	}
	else										//begin edit another property?
	{
		int nHeight = - GetScrollPos( SB_VERT);

		EProperty* pNewProperty = NULL;

		CPaintDC dc(this);
		dc.SelectObject(&m_Font);
		
		for( int i=0 ; i<m_PropList.Size() ; i++ )
		{
			EProperty* pProp = m_PropList.Get(i);

			if( pProp->m_Rect.Height() > 0 )
			{
				if( (pProp->m_Rect.top<=sp.y) && (sp.y<pProp->m_Rect.bottom) )
				{
					pNewProperty = pProp;

					if( pProp->m_bHasChildren )
					{
						if( pProp->m_NodeOpenRect.PtInRect(sp) )
						{
							if( pProp->m_bNodeOpen )
							{
								CloseNode( pProp );
							}
							else
							{
								OpenNode( pProp );
							}
						}
					}

					break;
				}
			}
		}

		//
		//
		//

		if( pNewProperty != NULL )
		{
			if( pNewProperty->IsSelectable()==false )
			{
				pNewProperty = NULL;
			}
		}

		SetActiveProperty(pNewProperty);
		EnsureVisibility( pNewProperty );

		if( m_pActiveProperty != NULL )
		{
			if( m_pActiveProperty->OnLButtonDown(this,sp) )
			{
				NotifyPropertyChanged();
			}
		}

		Invalidate();
	}
}


void EPropListCtrl::OnMouseMove(UINT nFlags, CPoint cp) 
{
	CPoint sp = _CP2SP(cp);

	if( nFlags & MK_LBUTTON )					//left button down?
	{
		if( m_nMouseDownMousePositionSP != -1 )	//dragging splitter?
		{
			int nDelta = sp.x - m_nMouseDownMousePositionSP;
			m_nKeyColumnWidth = m_nMouseDownKeyColumnWidth + nDelta;

			if( m_nKeyColumnWidth < 0 )
			{
				m_nKeyColumnWidth = 0;
			}

			m_ScrollPageSize.cx = m_nKeyColumnWidth + m_nSplitWidth + m_nOptimalValColumnWidth;

			SetScrollPage();
			Invalidate();
			
			SetCursor( LoadCursor(NULL,IDC_SIZEWE) );
		}
	}
	else
	{
		if( m_SplitRectSP.PtInRect(sp) )			//begin split move?
		{
			SetCursor( LoadCursor(NULL,IDC_SIZEWE) );
		}

		m_nMouseDownKeyColumnWidth  = -1;
		m_nMouseDownMousePositionSP = -1;
		ReleaseCapture();
	}

	// TODO: Add your message handler code here and/or call default
	
	CWnd::OnMouseMove(nFlags, cp);
}

BOOL EPropListCtrl::OnEraseBkgnd(CDC* pDC) 
{
	return FALSE;
}



CSize EPropListCtrl::GetScrollPageSize()
{
	return m_ScrollPageSize;
}

void EPropListCtrl::SetActiveTab(int i)
{
	if( i == m_PropList.GetActiveTab() )
	{
	}
	else
	{
		SetActiveProperty(NULL);
		m_PropList.SetActiveTab(i);

		CDC* pDC = GetDC();
		pDC->SelectObject( &m_Font );
		_UpdateDrawnPropertiesList(pDC);
		ReleaseDC(pDC);

		if (m_bAutoSizeKeyColumn)
		{
			AutoSizeKeyColumn();
		}

		Invalidate();

		if( m_pCommentPane!=NULL )
		{
			m_pCommentPane->Invalidate();
		}
	}
}

EPropList* EPropListCtrl::GetPropertyList()
{
	return &m_PropList;
}

CString EPropListCtrl::GetCurrentComment( CString& sObjectName )
{
	CString s;

	if( m_pPropertyHost != NULL )
	{
		if( m_pActiveProperty!=NULL )
		{
			s = m_pActiveProperty->GetComment();
			sObjectName = m_pActiveProperty->GetName();
		}
		else
		{
			s = m_PropList.m_sHostComment;
		}
	}

	return s;
}

void EPropListCtrl::SetPropertyHost( IPropertyHost* pHost )
{
	//
	// first apply and close old active property
	//

	OnDoPropApply();
	OnDoPropClose();
	ASSERT( m_pActiveProperty == NULL );

	//
	// if it's the same propertyhost, try to remember active tab
	//

	CString sOldActiveTab;

	if( m_PropList.HasUserTabs() )
	{
		int n = m_PropList.GetActiveTab();
		if( n>=0 )
		{
			EPropList::ETabGroup* pTab = m_PropList.GetTab(n);
			sOldActiveTab = *pTab->GetName();
		}
	}

	//
	//
	//
	
	m_PropList.Clear();

	ASSERT( m_PropList.Size() == 0 );
	ASSERT( m_PropList.GetTabCount() == 0 );
	ASSERT( m_PropList.HasUserTabs() == false );
	ASSERT( m_PropList.GetActiveTab() == -1 );

	m_pActiveProperty = NULL;
	m_pPropertyHost   = pHost;

	if( m_pPropertyHost == NULL )
	{
	}
	else
	{
		m_pPropertyHost->GetProperties( m_PropList );

		//
		// search for tab with same name as old list..
		//

		int nActiveTab = 0;
		int n = m_PropList.GetTabCount();
		for( int i=0 ; i<n ; i++ )
		{
			if( m_PropList.GetTab(i)->GetName()->CompareNoCase(sOldActiveTab)==0 )
			{
				nActiveTab = i;
			}
		}
		m_PropList.SetActiveTab(nActiveTab);

		if (m_bAutoSizeKeyColumn)
		{
			AutoSizeKeyColumn();
		}
	}



	CDC* pDC = GetDC();
	pDC->SelectObject( &m_Font );
	_UpdateDrawnPropertiesList(pDC);
	ReleaseDC(pDC);

	Invalidate();

	if( m_pCommentPane!=NULL )
	{
		m_pCommentPane->Invalidate();
	}

}

void EPropListCtrl::AutoSizeKeyColumn()
{
	//
	// try calculate default key column size
	//
	int nActiveTab = m_PropList.GetActiveTab();
	if ( nActiveTab>=0 )
	{
		int n = m_PropList.GetTab(nActiveTab)->Size();

		CPaintDC dc(this);
		dc.SelectObject(&m_Font);

		int nMargin = 4 * 2;
		for( int i=0 ; i<n ; i++ )
		{
			EProperty* pProp = m_PropList.GetTab(nActiveTab)->Get(i);
			CString s = pProp->GetName();
			CSize size = dc.GetTextExtent(s);
			if( size.cx + nMargin > m_nKeyColumnWidth )
			{
				m_nKeyColumnWidth = size.cx + nMargin;
			}
		}
	}
}

void EPropListCtrl::RefreshHostList()
{
	SetPropertyHost(m_pPropertyHost);
}

void EPropListCtrl::SetPropertyChangeListener( IPropertyChangeListener* pListener )
{
	m_pChangeListener = pListener;
}







void EPropListCtrl::StepSelection( int nStep )
{
//------------
//	int nNumProperties = m_PropList.Size();
//
//	for( int i=0 ; i<nNumProperties ; i++ )
//	{
//		EProperty* pProp = m_PropList.Get(i);
//		if( pProp == m_pActiveProperty )
//		{
//			i += nStep;
//
//			int i0 = 0;
//			int i1 = nNumProperties - 1;
//
//			if( i<i0 ) i=i0;
//			if( i>i1 ) i=i1;
//
//			EProperty* pNewActive = m_PropList.Get(i);
//
//			SetActiveProperty( pNewActive );
//			EnsureVisibility( pNewActive );
//			break;
//		}
//	}
//-------------

	for( int i=0 ; i<m_nNumDrawnProperties ; i++ )
	{
		if( m_pDrawnProperties[i] == m_pActiveProperty )
		{
			i += nStep;

			int i0 = 0;
			int i1 = m_nNumDrawnProperties - 1;

			//if( i<i0 ) i=i0;
			//if( i>i1 ) i=i1;

			EProperty* pNewActive = NULL;	//null is stepping outside because tab on last entry should also work, instead of "apply" being canceled

			if( i0<=i && i<=i1 )
			{
				pNewActive = m_pDrawnProperties[i];
			}

			SetActiveProperty( pNewActive );
			EnsureVisibility( pNewActive );

			break;
		}
	}

}

void EPropListCtrl::EnsureVisibility( EProperty* pProperty )
{
	if( pProperty!=NULL )
	{
		CRect r = pProperty->m_Rect;
		EnsureVisibility(r);
	}
}

void EPropListCtrl::EnsureVisibility( const CRect& r )
{
	CRect cr;
	GetClientRect(&cr);

	CPoint tl = _CP2SP( cr.TopLeft()     );
	CPoint br = _CP2SP( cr.BottomRight() );
	cr.SetRect( tl , br );

	int nCurrentScrollPos = GetScrollPos( SB_VERT );

	int nDeltay = 0;

	int nsp = -1;

	if( r.bottom > cr.bottom )
	{
		nsp = r.bottom - cr.Height();
		ASSERT(nsp>=0);

		cr.OffsetRect( 0 , nsp );
	}

	if( r.top < cr.top )							//hvis toppen kom over øverste..
	{
		nsp = r.top;
		ASSERT(nsp>=0);
	}

	if( nsp>=0 )
	{
		SetScrollPos( SB_VERT , nsp );
	}
}


BOOL EPropListCtrl::PreTranslateMessage( MSG* pMsg )
{
	BOOL bHandled = FALSE;

	if( pMsg->message == WM_KEYDOWN )
	{
		bHandled = TRUE;

		bool bControl = (GetKeyState(VK_CONTROL)&0x80000000) != 0;
		bool bShift   = (GetKeyState(VK_SHIFT)  &0x80000000) != 0;

		if( pMsg->wParam == VK_RETURN )
		{
			OnDoPropClose();
		}
		else if(pMsg->wParam == VK_ESCAPE)
		{
			m_bApplyOnKillFocus = false;
			OnDoPropClose();
		}
		else if(pMsg->wParam == VK_UP)
		{
			StepSelection( -1 );
		}
		else if(pMsg->wParam == VK_DOWN )
		{
			StepSelection( 1 );
		}
		else if(pMsg->wParam == VK_END )
		{
			bHandled = FALSE;
			if( m_pActiveProperty != NULL )
			{
				if( GetFocus() == this )
				{
					StepSelection( 1E6 );
					bHandled = TRUE;
				}
			}
		}
		else if(pMsg->wParam == VK_HOME )
		{
			bHandled = FALSE;
			if( m_pActiveProperty != NULL )
			{
				if( GetFocus() == this )
				{
					StepSelection( -1E6 );
					bHandled = TRUE;
				}
			}
		}
		else if(pMsg->wParam == VK_NEXT )
		{
			StepSelection( 3 );
		}
		else if(pMsg->wParam == VK_PRIOR )
		{
			StepSelection( -3 );
		}
		else if(pMsg->wParam == VK_TAB )
		{
			if(bShift)
			{
				StepSelection( -1 );
			}
			else
			{
				StepSelection(  1 );
			}
		}
		else if(pMsg->wParam == VK_RIGHT )
		{
			bHandled = FALSE;
			
			if( m_pActiveProperty != NULL )
			{
				if( m_pActiveProperty->m_bHasChildren )
				{
					if( GetFocus() == this )		//not the edit
					{
						if( m_pActiveProperty->m_bNodeOpen == false )
						{
							OpenNode( m_pActiveProperty );
							bHandled = TRUE;
						}
					}
				}
			}
		}
		else if(pMsg->wParam == VK_LEFT )
		{
			bHandled = FALSE;
			if( m_pActiveProperty != NULL )
			{
				if( m_pActiveProperty->m_bHasChildren )
				{
					if( GetFocus() == this )		//not the edit
					{
						if( m_pActiveProperty->m_bNodeOpen == true )
						{
							CloseNode( m_pActiveProperty );
							bHandled = TRUE;
						}
					}
				}
			}
		}
		else if(pMsg->wParam == VK_SPACE )
		{
			bHandled = FALSE;
			if( m_pActiveProperty != NULL )
			{
				if( GetFocus() == this )
				{
					if( m_pActiveProperty->OnSpaceKey() )
					{
						NotifyPropertyChanged();
						Invalidate();
						bHandled = TRUE;
					}

					if( m_pActiveProperty->m_bHasChildren )
					{
						if( m_pActiveProperty->m_bNodeOpen )
						{
							CloseNode( m_pActiveProperty );
						}
						else
						{
							OpenNode( m_pActiveProperty );
						}
						bHandled = TRUE;
					}

				}
			}
		}
		else
		{
			bHandled = FALSE;
		}
	}

	if( bHandled == FALSE )
	{
		bHandled = CWnd::PreTranslateMessage(pMsg);
	}

	return bHandled;
}


void EPropListCtrl::CloseNode( EProperty* pProp )
{
	if( pProp == NULL )
	{
		return;
	}

	if( pProp->m_bHasChildren == false )
	{
		return;
	}

	pProp->m_bNodeOpen = false;

	CDC* pDC = GetDC();
	pDC->SelectObject( &m_Font );
	_UpdateDrawnPropertiesList(pDC);
	ReleaseDC(pDC);

	Invalidate();
}

void EPropListCtrl::OpenNode( EProperty* pProp )
{
	if( pProp == NULL )
	{
		return;
	}

	if( pProp->m_bHasChildren == false )
	{
		return;
	}

	pProp->m_bNodeOpen = true;

	//
	//
	//

	int n = m_PropList.Size();

	CDC* pDC = GetDC();
	pDC->SelectObject( &m_Font );

	bool bReady = false;

	int nFirstChildY;

	CRect NodeRect;

	EProperty* pFirstOpeningChild = NULL;

	for( int i=0 ; i<n ; i++ )
	{
		EProperty* pCur = m_PropList.Get(i);		//find index of opening node
//		EProperty* pCur = m_pDrawnProperties[i];

		if( pCur==pProp )							//this is it
		{
			int nOpeningNodeIndent = pProp->m_nIndent;

			i++;									//first opening child
			pFirstOpeningChild = m_PropList.Get(i);

			NodeRect = pProp->m_Rect;

			nFirstChildY = NodeRect.bottom;

			bReady = false;

			while(i<n)
			{
				pCur = m_PropList.Get(i);
//				pCur = m_pDrawnProperties[i];

				if( nOpeningNodeIndent == pCur->m_nIndent )		//found the 'brother-node' that had same indent
				{
					bReady = true;
				}
				else
				{
					NodeRect.bottom += pCur->GetHeight(pDC) + 2 * m_nEdgeWidth;
				}

				i++;

				if( i==n )
				{
					bReady = true;
				}

				if( bReady )
				{
//					EnsureVisibility(r);
					break;
				}
			}
		}
	}

	m_nAnimChildrensHeight = NodeRect.bottom - nFirstChildY;

	//
	//
	//

	_UpdateDrawnPropertiesList(pDC);

	//
	// find the drawnproperties index of first opening child
	//

	for( i=0 ; i<m_nNumDrawnProperties ; i++ )
	{
		if( pFirstOpeningChild==m_pDrawnProperties[i] )
		{
			m_nAnimFirstOpeningChild = i;
			break;
		}
	}

	//
	//
	//
	
	if( bReady )
	{
		EnsureVisibility(NodeRect);
	}

	ReleaseDC(pDC);

	//
	//
	//

//---------
	m_nAnimCurrentFrame = 0;
	m_bAnimating = true;
	int nFPS = 60;
	SetTimer( 0 , 1000/nFPS , NULL );
//---------
//	Invalidate();
//---------
}

void EPropListCtrl::OnLButtonDblClk( UINT nFlags, CPoint point )
{
	if( m_pActiveProperty != NULL )
	{
		if( m_pActiveProperty->m_bHasChildren )
		{
			if( m_pActiveProperty->m_bNodeOpen )
			{
				CloseNode( m_pActiveProperty );
			}
			else
			{
				OpenNode( m_pActiveProperty );
			}
			Invalidate();
		}
	}
}

